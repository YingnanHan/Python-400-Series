'''

协程（英语：coroutine）是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，
协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常
处理、事件循环、迭代器、无限列表和管道。

根据高德纳的说法, 马尔文·康威于1958年发明了术语“coroutine”并用于构建汇编程序[1] ，关于协程最初的出版解说在1963
年发表[2]。

协程可以通过yield（取其“让步”之义而非“出产”）来调用其它协程，接下来的每次协程被调用时，从协程上次yield返回的位
置接着执行，通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。由于协程不如子例程
那样被普遍所知，下面对它们作简要比较：

子例程可以调用其他子例程，调用者等待被调用者结束后继续执行，故而子例程的生命期遵循后进先出，即最后一个被调用的子例
程最先结束返回。协程的生命期完全由对它们的使用需要来决定。子例程的起始处是惟一的入口点，每当子例程被调用时，执行都
从被调用子例程的起始处开始。协程可以有多个入口点，协程的起始处是第一个入口点，每个yield返回出口点都是再次被调用执行
时的入口点。子例程只在结束时一次性的返回全部结果值。协程可以在yield时不调用其他协程，而是每次返回一部分的结果值，这
种协程常称为生成器或迭代器。现代的指令集架构通常提供对调用栈的指令支持，便于实现可递归调用的子例程。在以Scheme为代
表的提供续体的语言环境下[3]，恰好可用此控制状态抽象表示来实现协程。子例程可以看作是特定状况的协程[4]，任何子例程都可
转写为不调用yield的协程[5]。

'''